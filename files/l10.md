---
title: "Lecture 10"
permalink: /files/l10/
author_profile: false
---

# Knowledge Representation

Let us again consider the MopBot example. Remember, our MopBot has:

-   Sensors, which enables it to detect whether there is dirt in the room.
-   Actuators, which enables it to clean the room or move to another room.

Suppose, we want to tell that MopBot should clean the room _B_ and come back to room _A_. It might develop the following simple plan $$p_1$$ to achieve the goal:

1. Move to _B_.
2. Clean _B_.
3. Leave _B_ when no dirt is detected.

Alternatively, the MopBot may also adopt a more complex plan $$p_2$$ to achieve the goal:

1. Move to _B_.
2. If dirt is detected, clean _B_. Otherwise, there is no need to clean.
3. Leave _B_ when no dirt is detected.

Here, MopBot had known two things:

-   No dirt detected when room is clean.
-   Leave room _B_ when no dirt detected.

From above two statements, we want MopBot to have knowledge of leave room _B_ when room is clean, in other-words, we want the MopBot to somehow store this knowledge.

## 10.1 Propositional logic

Knowledge is a concept that is very hard to define, but one definition of knowledge that has been generally agreed upon is: An agent _A_ knows that statement _S_ is true if and only if:

1. _S_ is true.
2. _A_ believes _S_ is true.
3. _A_ is justified in believing that _S_ is true.

$~~~~$We will now introduce the idea of $$propositions$$, which are variables that take on values $$True$$ or $$False$$. We can decide whether or not we can make such deductions by replacing these statements with propositions. For instance, assume

-   $$g$$ represent Greeks,
-   $$h$$ represent Humans,
-   $$m$$ represent Mortals.

<div align="center">
All greeks are human. $~~~~~$| $~$ $g$ → $h$ <br /> 
All humans are mortal. $~~~~~$| $~$ $h$ → $m$ <br /> 
<hr align ="center" style="border: 0.3px solid black; width:40%; margin:0px;">
All greeks are mortal. $~~~~~~$| $~$ $g$ → $m$
<hr align ="center" style="border: 1px solid black; width:40%; margin:0px">
</div>
<br />
$~~~~$The problem is in general we can not differentiate between whether statement *S* is true or Agent *A* believes that *S* is true. With the statements “all Greeks are human” and “all humans are mortal”, we can deduce that “all Greeks are mortal”. However, with “not all Greeks are human” and “all humans are mortal”, we are not able to deduce that “not all Greeks are mortal”.

<div align="center">
Not all greeks are human. $~~~~~$| $~~~~~~~~~~~~~~~~~~~~~~~$<br /> 
All humans are mortal. $~~~~~~$| $~~~~~~~~~~~~~~~~~~~$<br /> 
<hr align ="center" style="border: 0.3px solid black; width:50%; margin:0px;">
Not all greeks are mortal. $~~~~~$| $~$ can’t deduce
<hr align ="center" style="border: 1px solid black; width:50%; margin:0px">
</div>
<br />

$~~~~$After introducing propositions, we need a way of combining them to construct meaningful sentences.
This led to the introduction of operators, including:

-   unary operators: $¬$ (Negation)
-   binaryoperations: $∧$ and $∨$, $a→b≡¬a∨b$

Finally, we would want to be able to express our knowledge base($$KB$$). The language of Knowledge base:

-   $$PROP$$: the set of all propositions, and
-   $$FORM$$: the set of all formulas/sentences that can be expressed by propositional logic.

Using these expressions, we will be able to classify which statements are allowed in propositional logic, and which are not allowed. For instance, $$(p ∨ q)$$ is allowed under $$PROP$$ and $$FORM$$, whereas $$(p ∧ q)$$ is not allowed. $$FORM$$ can be recursively defined as such:

$$~~~~~~~~~~FORM_0 = PROP$$ <br />
$$~~~~~~FORM_{i+1} = FORM_i ∪ \{(α ◦ β)|α, β ∈ FORM_i\} ∪ \{(¬α)|α ∈ FORM_i\}$$
$$~~~~~~~~~~~~FORM = \bigcup\limits_{i=0}^{\infty}  FORM_i $$ <br />

where $$α ◦ β ≡ \{(α ∨ β)\} ∨ \{(α ∧ β)\}$$. Every $$α ∈ KB$$ is also in $$FORM$$. <br />
$~~~~$Every formula $$φ$$ may be true or false depending on the situation. For example: $$p ∨ q$$ is true when
$$p=0$$ and $$q=1$$, but false when $$p=0$$, $$q=0$$. Here, we define the notion of truth assignment $$τ$$.

<center>$$τ : PROP →\{0,1\} \nonumber$$</center>

If a formula $$φ$$ is true in $$τ$$, we say $$τ \models φ$$. To check whether $$τ \models φ$$ or not, we can substitute every propositional variables with its truth assignment, and if $$φ$$ evaluates to true then $$τ \models φ$$ else not.

<center>$τ \models φ$ iff $φ ( τ ) = 1$</center>

where $$φ(τ)$$ is $$φ$$ after substituting propositions of $$φ$$ with their values in $$τ$$.

Let us consider an example to understand the aforementioned statement.
$$~~~~φ=((P ∨q)∧(¬r))$$ <br />
$$~~~~τ_1 =\{p→1,q→1,r→1\} ~~~~~~~~~~~~~~~~~~~~~~~~~ φ(τ_1)=0 ~~~~~~~~~~~~~~~~~~~~~~~~~ τ_1 \not\modelsφ $$ <br />
$$~~~~τ_2 =\{p→1,q→0,r→0\} ~~~~~~~~~~~~~~~~~~~~~~~~~ φ(τ_2)=1 ~~~~~~~~~~~~~~~~~~~~~~~~~ τ_2 \models φ$$

There are $$2^{\vert PROP \vert}$$ truth assignment possible.

-   $$φ$$ is SAT(Satisfiable): $$∃τ$$ such that $$τ \models φ$$.
-   $$φ$$ is Valid: $$∀τ, τ \models φ$$.
-   $$φ$$ is UNSAT(Unsatisfiable): $$∀τ,τ \not\models φ$$ or there does not exists $$τ$$ such that $$τ \models φ$$.
-   One important observation: $$φ$$ **is VALID iff** $$¬φ$$ **is UNSAT**.

A few examples to understand the above definitions.

-   $$(p ∨ ¬p)$$ is VALID, SAT.
-   $$(p ∨ q)$$ is SAT, but not VALID.
-   $$(p∨q)∧(¬p∨q)∧(p∨¬q)∧(¬p∨¬q)$$ is UNSAT.

$~~~~$This allows us to find meanings in the sentences; for example $$(p ∨ q)$$ and $$(q ∨ p)$$ are different strings but seem to have meanings. In general two formulas $$φ$$ and $$Φ$$ are called semantically equivalent $$(φ ↔ Φ)$$ if following holds:

<center>$φ ↔ ψ$ iff $∀τ,φ(τ) = ψ(τ)$</center>

Some definitions:

-   $ψ\models φ$ iff $ψ→φ$ is VALID.
-   $ψ\equiv φ$ iff $ψ↔φ$ is VALID.
-   If $ψ\equiv φ$, then $$φ$$ and $$ψ$$ are called semantically equivalent.

$~~~~$For example: let $$φ = (p ∨ (q ∧ r))$$ and $$Φ = ((p ∨ q) ∧ r)$$. $$φ \not\leftrightarrow Φ$$ as for $$τ = \{p → 1, q → 1, r → 0\}$$, $$φ(τ)\ne ψ(τ)$$. Similarly:

<center>$(C1 ∧(C2 ∧(C3 ∧C4)))↔((C1 ∧C2)∧(C3 ∧ C4))$</center>

Where $$C_1, C_2, C_3, C_4 ∈ FORM$$. Essentially, the position of parenthesis does not matter when all $$C_i$$’s
are connected with $$∧$$; in that case, we are going to simply pretend that parenthesis do not exists.

## 10.2 Conjunctive Normal Form(CNF)

<center>$$C_1 ∧C_2 ∧C_3 ∧...∧ C_m \nonumber$$</center>
Where every $$Clause ~ C_i$$ is expressed as disjunction of $$Literals$$. <br />
$$C_i =(l_{1_i} ∨l_{2_i} ∨...∨l_{k_i})$$ where $$l_{j_i} ∈ \{p\vert p∈PROP\}∪\{¬p\vert p∈PROP\}$$. Example:

$$~~~~~~~~~~C_1 :(p∨q∨¬r)$$ <br />
$$~~~~~~~~~~C_2 :(q∨¬s∨r)$$ <br />
$$~~~~~~~~~~C_3 :(p∨¬q∨s)$$ <br />
$$~~~~~~~~~~~~φ:C_1 ∧C_2 ∧C_3$$
